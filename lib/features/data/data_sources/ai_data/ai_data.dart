import 'dart:async';
import 'dart:developer';
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_gemini/flutter_gemini.dart';
import 'package:official_chatbox_application/config/bloc_providers/all_bloc_providers.dart';
import 'package:official_chatbox_application/core/constants/database_name_constants.dart';
import 'package:official_chatbox_application/core/enums/enums.dart';
import 'package:official_chatbox_application/core/service/dialog_helper.dart';
import 'package:official_chatbox_application/features/data/models/message_model/message_model.dart';

class AIData {
  final FirebaseFirestore firebaseFirestore;

  AIData({
    required this.firebaseFirestore,
  });

  final senderID = FirebaseAuth.instance.currentUser?.uid;
  final boxAIId = 'boxAI1234';
  Gemini gemini = Gemini.instance;

  Future<bool> sendMessageInAIChat({
    required String messageText,
  }) async {
    try {
      // Create message model for user's message
      MessageModel userMessage = MessageModel(
        isDeletedMessage: false,
        isEditedMessage: false,
        isPinnedMessage: false,
        message: messageText,
        messageType: MessageType.text,
        messageStatus: MessageStatus.read,
        messageTime: DateTime.now().toString(),
        receiverID: boxAIId,
        senderID: senderID,
      );
      // Save user's message to Firestore
      final userMessageDoc = await firebaseFirestore
          .collection(usersCollection)
          .doc(senderID)
          .collection(aiChatMessagesCollection)
          .add(userMessage.toJson());
      // get the id of user message document
      final docId = userMessageDoc.id;
      final updatedUserMessageModel = userMessage.copyWith(
        messageId: docId,
      );
      // again update the userMessage doc with the id
      await firebaseFirestore
          .collection(usersCollection)
          .doc(senderID)
          .collection(aiChatMessagesCollection)
          .doc(docId)
          .update(updatedUserMessageModel.toJson());
      // Send the message to the AI and get a response
      final String aiResponse = await getAIResponse(messageText);
      // Create message model for AI's response
      MessageModel aiMessageModel = MessageModel(
        isDeletedMessage: false,
        isEditedMessage: false,
        isPinnedMessage: false,
        message: aiResponse,
        messageType: MessageType.text,
        messageStatus: MessageStatus.read,
        messageTime: DateTime.now().toString(),
        receiverID: senderID,
        senderID: boxAIId,
      );
      // get the AI message doc
      final aiMessageDoc = await firebaseFirestore
          .collection(usersCollection)
          .doc(senderID)
          .collection(aiChatMessagesCollection)
          .add(aiMessageModel.toJson());
      // get the id of AI message doc
      final aiDocId = aiMessageDoc.id;
      // update it the id
      final updateAIMessageModel = aiMessageModel.copyWith(
        messageId: aiDocId,
      );
      // and update in database also
      await firebaseFirestore
          .collection(usersCollection)
          .doc(senderID)
          .collection(aiChatMessagesCollection)
          .doc(aiDocId)
          .update(updateAIMessageModel.toJson());
      // return true after all completed successfully
      return true;
    } on FirebaseException catch (e) {
      log("Chat AI messaging Firebase error: ${e.message}");
      if (e.code == 'unavailable') {
        DialogHelper.showDialogMethod(
          title: "Network Error",
          contentText: "Please check your network connection",
        );
      }
      return false;
    } on SocketException catch (e) {
      DialogHelper.showDialogMethod(
        title: "Network Error",
        contentText: "Please check your network connection",
      );
      return false;
    } catch (e) {
      return false;
    }
  }

  Future<String> getAIResponse(String message) async {
    try {
      // Create a Completer object to manually complete a Future when the response is fully received.
      final completer = Completer<String>();
      // Initialize an empty string to collect and combine the parts of the response.
      String geminiResponseMessage = '';
      // Listen to the stream of data generated by the AI service.
      gemini.streamGenerateContent(message).listen(
        (data) {
          // Accumulate response parts into the geminiResponseMessage variable.
          // The `fold` function is used to concatenate the text from each part.
          // If parts are null, it defaults to an empty string.
          geminiResponseMessage += data.content?.parts?.fold(
                  "", (previous, current) => "$previous ${current.text}") ??
              '';

          log(geminiResponseMessage.toString());
        },
        onError: (error) {
          // If an error occurs while streaming, complete the completer with an error.
          // Ensure that the completer is not already completed to prevent exceptions.
          if (!completer.isCompleted) {
            completer.completeError(error);
          }
        },
        onDone: () {
          // When the stream is finished:
          // Remove any unwanted characters (e.g., '*' in this case) from the collected and combined response.
          geminiResponseMessage = geminiResponseMessage.replaceAll('*', '');
          // Again, ensure the completer is not already completed.
          if (!completer.isCompleted) {
            completer.complete(geminiResponseMessage);
          }
        },
      );

      // Await the completion of the completer's Future, which will contain the final response.
      return await completer.future;
    } catch (e) {
      log("Error getting AI response: $e");
      // Return a fallback error message to indicate the failure.
      return "Sorry, I couldn't understand that.";
    }
  }

  Stream<List<MessageModel>>? getAllAIChatMessages() {
    try {
      // get current user id
      final currentUserId = firebaseAuth.currentUser?.uid;
      // get all messages in ai chat and return the stream messages list
      return fireStore
          .collection(usersCollection)
          .doc(currentUserId)
          .collection(aiChatMessagesCollection)
          .orderBy(
            dbMessageSendTime,
            descending: false,
          )
          .snapshots()
          .map((snapData) {
        return snapData.docs
            .map((doc) => MessageModel.fromJson(map: doc.data()))
            .toList();
      });
    } on FirebaseException catch (e) {
      log("Chat AI get message Firebase error: ${e.message}");
      if (e.code == 'unavailable') {
        DialogHelper.showDialogMethod(
          title: "Network Error",
          contentText: "Please check your network connection",
        );
      }
      return null;
    } on SocketException catch (e) {
      DialogHelper.showDialogMethod(
        title: "Network Error",
        contentText: "Please check your network connection",
      );
    } catch (e) {
      return null;
    }
  }

  Future<bool> deleteMessage({
    required String messageId,
  }) async {
    try {
      // get current user id
      final currentUserId = firebaseAuth.currentUser?.uid;
      // delete a particular message from ai chat
      await fireStore
          .collection(usersCollection)
          .doc(currentUserId)
          .collection(aiChatMessagesCollection)
          .doc(messageId)
          .delete();
      return true;
    } on FirebaseException catch (e) {
      if (e.code == 'unavailable') {
        DialogHelper.showDialogMethod(
          title: "Network Error",
          contentText: "Please check your network connection",
        );
      }
      return false;
    } on SocketException catch (e) {
      DialogHelper.showDialogMethod(
        title: "Network Error",
        contentText: "Please check your network connection",
      );
      return false;
    } catch (e) {
      return true;
    }
  }

  Future<bool> clearChat() async {
    try {
      // get current user id
      final currentUserId = firebaseAuth.currentUser?.uid;
      // get current user ai message snapshot
      final messagesSnapshot = await fireStore
          .collection(usersCollection)
          .doc(currentUserId)
          .collection(aiChatMessagesCollection)
          .get();
          // delete all messages
      for (var messageDoc in messagesSnapshot.docs) {
        await messageDoc.reference.delete();
      }
      return true;
    } on FirebaseException catch (e) {
      log("Chat AI clear chat Firebase error: ${e.message}");
      if (e.code == 'unavailable') {
        DialogHelper.showDialogMethod(
          title: "Network Error",
          contentText: "Please check your network connection",
        );
      }
      return false;
    } on SocketException catch (e) {
      DialogHelper.showDialogMethod(
        title: "Network Error",
        contentText: "Please check your network connection",
      );
      return false;
    } catch (e) {
      log("Chat AI clear chat error: $e");
      return false;
    }
  }
}
